% Chapter 5: Code generation using patterns

\chapter{Code generation using patterns}

\label{ch:fifth} % For referencing the chapter elsewhere, use \autoref{ch:name} 
\label{chapter:codeGeneration}

In the last two chapters we discussed how regular parallel pattern, referred to as \emph{algorithmic skeletons}, help to greatly simplify programming of modern parallel systems.
Parallel programming of multi-\GPU systems is considerably simplified without scarifying performance as shown in \autoref{chapter:skelcl-evaluation}.
In this chapter we address the second main challenge identified in \autoref{chapter:background}: \emph{Performance portability}.
We will present a novel approach for generating efficient and specialized code from compositions of algorithmic skeletons and similar high-level \emph{patterns}.
This systematic, rule-based approach provides performance portability across different types of modern parallel processors. 
In the following \autoref{chapter:codeGeneration-evaluation} we will show that this approach generates code matching the performance of highly tuned implementations on \CPUs and \GPUs using a set of example application.

We will start the chapter by looking at common optimizations in \OpenCL and how applying them changes the source code of applications.
We will show how these optimizations can be hardware specific breaking portability and, furthermore, how optimizations for one particular hardware architecture can lead to poor performance on other hardware architectures.
All of this will motivate the necessity, when aiming for performance portability, for generating code from a pattern-based high-level representation.
We will discuss the benefits an approach using code generation offers over a library based approach, like \SkelCL presented in \autoref{chapter:skelcl}.
Then we will give an overview of our approach and present it in more detail in the following sections.
\autoref{chapter:codeGeneration-evaluation} will present an evaluation of the approach using a set of application studies.

\input{Chapters/Chapter5/motivation.tex}

\input{Chapters/Chapter5/overview.tex}

\input{Chapters/Chapter5/patterns.tex}

\input{Chapters/Chapter5/rules.tex}

\section{Implementation Details}

Our system is implemented in \Cpp, using the template system and support for lambda functions. 
When generating code for a given low-level expression, two basic steps are performed.
First, we use the Clang/LLVM compiler infrastructure to parse the expression and produce an abstract syntax tree for it.
Second, we traverse the tree and emit code for every function call representing one of our low-level hardware patterns.

As part of the first step, we have developed a type system which plays a dual role.
Firstly, it prevents the user, or a rewrite rule, to produce an expression that is not correct.
Secondly, the type system encodes informations that are necessary for code generation, such as memory address space and array size information, which are used to allocate memory.

The design of our code generator is straightforward since no optimization decisions are made at this stage.
We avoid performing complex analysis of the code which makes our design very different compared to traditional optimizing compilers.

