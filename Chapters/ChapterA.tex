% Appendix A

\chapter{Correctness of Rewrite Rules}
\label{chapter:proofs}
\addtocontents{lof}{\protect\vspace{\beforebibskip}}%

This appendix present the proofs which show, that the rewrite rules presented in \autoref{section:rules} do not change the semantics of pattern-based programs.

\section{Algorithmic Rules}

This section shows the proofs for the algorithmic rules defined in \autoref{section:rules:algo}.

\paragraph{Identity}

We repeat \autoref{eq:algo:identity} here:
\begin{rerule*}{lclcl}
  f & \rightarrow & f \circ \map\ \textit{id} & | & \map\ \textit{id} \circ f
\end{rerule*}

\begin{proof}[Proof of option 1]
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
    (f \circ \map\ \textit{id})\ xs
      &= f\ (\map\ \textit{id}\ xs)\\
      &\begin{aligned}[t]
        & \comment{definition of \map}                                         && \comment{definition of \textit{id}}\\
        &= f\ ([\textit{id}\ x_1, \textit{id}\ x_2, \ldots, \textit{id}\ x_n]) &&= f\ xs
      \end{aligned}
  \end{align*}
\end{proof}
\begin{proof}[Proof of option 2]
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
    (\map\ \textit{id} \circ\ f)\ xs
      &= \map\ \textit{id}\ (f\ xs)\\
      & \comment{definition of \map}\\
      &= [\textit{id}\ (f\ xs)_1, \textit{id}\ (f\ xs)_2, \ldots, \textit{id}\ (f\ xs)_n]\\
      & \comment{definition of \textit{id}}\\
      &= f\ xs
  \end{align*}
\end{proof}

\paragraph{Iterate decomposition}

We repeat \autoref{eq:algo:iterate} here:
\begin{rerule*}{lcl}
  \iterateN\ 1\ f & \rightarrow & f\\
  \iterateN\ (m+n)\ f
    & \rightarrow &
      \iterateN\ m\ f
        \circ \iterateN\ n\ f
\end{rerule*}

\begin{proof}[Proof of option 1]
  \begin{align*}
      & \comment{definition of \iterateN} && \comment{definition of \iterateN}\\
    \iterateN\ 1\ f\ xs
      &= \iterateN\ (1-1)\ f\ (f\ xs) \hspace{-5em}&& = f\ xs
  \end{align*}
\end{proof}
\begin{proof}[Proof of option 2]
  Proof by induction.
  We start with the base case, let $n=0$:
  \begin{align*}
      & \comment{definition of \iterateN}\\
    \iterateN\ (m+0)\ f\ xs
      &= \iterateN\ m\ f\ (\iterateN\ 0\ f\ xs)\\
      & \comment{definition of \iterateN}\\
      &= (\iterateN\ m\ f \circ \iterateN\ 0\ f)\ xs
  \end{align*}
  We finish with the induction step $n-1 \rightarrow n$:
  \begin{align*}
      & \comment{definition of \iterateN}\\
    \iterateN\ (m+n)\ f\ xs
      &= \iterateN\ (m+n-1)\ f\ (f\ xs)\\
      & \comment{induction hypothesis}\\
      &= (\iterateN\ m\ f\ \circ \iterateN\ (n-1)\ f) (f\ xs)\\
      & \comment{definition of $\circ$}\\
      &= \iterateN\ m\ f\ (\iterateN\ (n-1)\ f\ (f\ xs))\\
      & \comment{definition of \iterateN}\\
      &= \iterateN\ m\ f\ (\iterateN\ n\ f\ xs)\\
      & \comment{definition of $\circ$}\\
      &= (\iterateN\ m\ f \circ \iterateN\ n\ f)\ xs
  \end{align*}
\end{proof}


\paragraph{Reorder commutativity}
We repeat \autoref{eq:algo:reorder} here:
\begin{rerule*}{lcl}
  \map\ f \circ \reorder
    & \rightarrow & \reorder \circ \map\ f\\
  \reorder \circ \map\ f
    & \rightarrow & \map\ f \circ \reorder
\end{rerule*}

\begin{proof}[Proof]
  We start with the expression $\map\ f \circ \reorder$.\\
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
    (\map\ f \circ \reorder)\ xs
      &= \map\ f\ (\reorder\ xs)\\
      & \comment{definition of \reorder}\\
      &= \map\ f\ [x_{\sigma(1)}, \ldots, x_{\sigma(n)}]\\
      & \comment{definition of \map}\\
      &= [f\ x_{\sigma(1)}, \ldots, f\ x_{\sigma(n)}]
  \end{align*}
  Now we investigate the expression $\reorder \circ \map\ f$:
  \begin{align*}
    (\reorder \circ \map\ f)\ xs
      &= \reorder\ (\map\ f\ xs)\\
      & \comment{definition of \map}\\
      &= \reorder\ [f\ x_1, \ldots, f\ x_n]\\
      &= \reorder\ [y_1, \ldots, y_n]\qquad \text{with } y_i = f\ x_i\\
      & \comment{definition of \reorder}\\
      &= [y_{\sigma(1)}, \dots, y_{\sigma(n)}]\\
      & \comment{definition of $y_i$}\\
      &= [f\ x_{\sigma(1)}, \ldots, f\ x_{\sigma(n)}]
  \end{align*}
  As both expression we started with can be simplified to the same expression they have the same semantics, therefore, both options of the rule are correct.
\end{proof}

\paragraph{Split-join}

We repeat \autoref{eq:algo:splitjoin} here:
\begin{rerule*}{lcl}
  \map\ f
    & \rightarrow &
      \join \circ \map\ (\map\ f) \circ \splitN\ n
\end{rerule*}

\begin{proof}[Proof]
  We start from the right-hand side and show the equality of both sides.
  Let $xs = [x_1, \ldots, x_m]$.
  \begin{align*}
    &(\join \circ \map\ (\map\ f) \circ \splitN\ n)\ xs = \join\ (\map\ (\map\ f)\ (\splitN\ n\ xs))\\
    &\qquad \comment{definition of \splitN}\\
    &\qquad = \join\ (\map\ (\map\ f)\ [[x_1, \ldots, x_n], \ldots, [x_{m-n+1}, \ldots, x_m]])\\
    &\qquad \comment{definition of \map}\\
    &\qquad = \join\ [\map\ f\ [x_1, \ldots, x_n], \ldots, \map\ f\ [x_{m-n+1}, \ldots, x_m]]\\
    &\qquad \comment{definition of \map}\\
    &\qquad = \join\ [[f\ x_1, \ldots, f\ x_n], \ldots, [f\ x_{m-n+1}, \ldots, f\ x_m]]\\
    &\qquad \comment{definition of \join}\\
    &\qquad = [f\ x_1, \ldots, \ldots, f\ x_m]\\
    &\qquad \comment{definition of \map}\\
    &\qquad = \map\ f\ xs
  \end{align*}
\end{proof}

\paragraph{Reduction}

We repeat \autoref{eq:algo:red} here:
\begin{rerule*}{lcl}
  \reduce\ (\oplus)\ \id_\oplus
    & \rightarrow &
      \reduce\ (\oplus)\ \id_\oplus \circ \partRed\ (\oplus)\ \id_\oplus
\end{rerule*}

\begin{proof}[Proof]
  We start from the right-hand side and show the equality of both sides.
  Let $xs = [x_1, \ldots, x_m]$.
  \begin{align*}
    &(\reduce\ (\oplus)\ \id_\oplus \circ \partRed\ (\oplus)\ id_\oplus\ n)\ xs\\
    &\qquad = \reduce\ (\oplus)\ \id_\oplus\ (\partRed\ (\oplus)\ id_\oplus\ n\ xs)\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = \reduce\ (\oplus)\ \id_\oplus\\
    &\qquad\qquad [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)},\ \dots ,\ x_{\sigma(m-n+1)} \oplus \dots \oplus x_{\sigma(m)}]\\
    &\qquad \comment{definition of \reduce}\\
    &\qquad = [(x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}) \oplus \dots \oplus (x_{\sigma(m-n+1)} \oplus \dots \oplus x_{\sigma(m)})]\\
    &\qquad \comment{commutativity \& accociativity of $\oplus$}\\
    &\qquad = [x_1 \oplus \dots \oplus x_m]\\
    &\qquad \comment{definition of \reduce}\\
    &\qquad = \reduce\ (\oplus)\ \id_\oplus\ xs
  \end{align*}
\end{proof}


\paragraph{Partial Reduction}

We repeat \autoref{eq:algo:part-red} here:
\begin{rerule*}{lcl}
  \partRed\ (\oplus)\!\!\!\! &\id_\oplus&\!\!\!\! n\\
    & \rightarrow &
      \reduce\ (\oplus)\ \id_\oplus\\
    & | &
      \partRed\ (\oplus)\ \id_\oplus\ n \circ \reorder\\
    & | &
      \join_m \circ \map\ (\partRed\ (\oplus)\ \id_\oplus\ n) \circ \splitN\ m\\
    & | &
      \iterateN\ \log_m(n)\ (\partRed\ (\oplus)\ \id_\oplus\ m)
\end{rerule*}

\begin{proof}[Proof of option 1]
  Let $xs = [x_1, \ldots, x_m]$.
  Since the rules can only be valid if their types matches it must hold $n=m$.
  \begin{align*}
    &(\partRed\ (\oplus)\ \id_\oplus\ m)\ [x_1, \ldots, x_m]\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(m)}]\\
    &\qquad \comment{commutativity of $\oplus$} \quad \comment{definition of \reduce}\\
    &\qquad = [x_1 \oplus \dots \oplus x_m]\qquad =\quad \reduce\ (\oplus)\ \id_\oplus\ xs
  \end{align*}
\end{proof}

\begin{proof}[Proof of option 2]
  Let $xs = [x_1, \ldots, x_m]$
  \begin{align*}
    &\partRed\ (\oplus)\ \id_\oplus\ n\ xs\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)},\ \ldots,\ x_{\sigma(m-n+1)} \oplus \dots \oplus x_{\sigma(m)}]\\
    &\qquad \comment{represent permutation $\sigma$ with appropiate permutations $\sigma'$, $\sigma''$}\\
    &\qquad =
      \begin{aligned}[t]
        \big[&x_{\sigma'(\sigma''(1))} \oplus \dots \oplus x_{\sigma'(\sigma''(n))}, \ldots,\\
         &x_{\sigma'(\sigma''(m-n+1))} \oplus \dots \oplus x_{\sigma'(\sigma''(m))}\big]
       \end{aligned}\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = \partRed\ (\oplus)\ \id_\oplus\ n\ [x_{\sigma''(1)}, \ldots, x_{\sigma''(m)}]\\
    &\qquad \comment{definition of \reorder}\\
    &\qquad = \partRed\ (\oplus)\ \id_\oplus\ n\ (\reorder\ xs)\\
    &\qquad = (\partRed\ (\oplus)\ \id_\oplus\ n \circ \reorder)\ xs
  \end{align*}
\end{proof}

\begin{proof}[Proof of option 3]
  Let $xs = [x_1, \ldots, x_l]$.
  \begin{align*}
    &\partRed\ (\oplus)\ \id_\oplus\ n\ xs\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}, \ldots, x_{\sigma(l-n+1)} \oplus \dots \oplus x_{\sigma(l)}]\\
    &\qquad \comment{represent permutation $\sigma$ with appropiate permutations $\sigma_i$}\\
    &\qquad 
      \begin{array}{ll}
      = & \big[\ x_{\sigma_1(1)} \oplus \dots \oplus x_{\sigma_1(n)},\ \ldots,\\
        & \ \ \ \ x_{\sigma_1(m-n+1)} \oplus \dots \oplus x_{\sigma_1(m)},\\
        & \ \ \ \ldots,\\
        & \ \ \ x_{\sigma_{l/m}(l-m+1)} \oplus \dots \oplus x_{\sigma_{l/m}(l-m+n+1)},\ \ldots,\\
        & \ \ \ \ x_{\sigma_{l/m}(l-n+1)} \oplus \dots \oplus x_{\sigma_{l/m}(l)}\ \big]
      \end{array}\\
    &\qquad \comment{definition of $\join_m$}\\
    &\qquad
      \begin{array}{lll}
        = \join_m\ \big[&  &[\ x_{\sigma_1(1)} \oplus \dots \oplus x_{\sigma_1(n)},\\
             &  &\ \ \ldots,\\
             &  &\ \ x_{\sigma_1(m-n+1)} \oplus \dots \oplus x_{\sigma_1(m)}],\\
             &\multicolumn{2}{l}{\ldots,}\\
             &  &[\ x_{\sigma_{l/m}(l-m+1)} \oplus \dots \oplus x_{\sigma_{l/m}(l-m+n+1)},\\
             &  &\ \ \ldots,\\
             &  &\ \ x_{\sigma_{l/m}(l-n+1)} \oplus \dots \oplus x_{\sigma_{l/m}(l)}]\qquad\big]
      \end{array}\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = \join_m\
      \begin{aligned}[t]
        \big[\ &\partRed\ (\oplus)\ \id_\oplus\ n\ [x_1, \ldots, x_m],\\
               &\ldots,\\
               &\partRed\ (\oplus)\ \id_\oplus\ n\ [x_{l-m+1+}, \ldots, x_l]\ \big]
      \end{aligned}\\
    &\qquad \comment{definition of \map}\\
    &\qquad = \join_m\ \big(\map\ (\partRed\ (\oplus)\ \id_\oplus\ n)\\
    &\qquad\qquad \big[[x_1, \ldots, x_m], \ldots, [x_{l-m+1+}, \ldots, x_l]\big]\big)\\
    &\qquad \comment{definition of \splitN}\\
    &\qquad = \join_m\ \big(\map\ (\partRed\ (\oplus)\ \id_\oplus\ n)\ (\splitN\ m\ xs)\big)\\
    &\qquad = (\join_m \circ \map\ (\partRed\ (\oplus)\ \id_\oplus\ n) \circ \splitN\ m)\ xs
  \end{align*}
\end{proof}
\newpage

\begin{proof}[Proof of option 4]
  We will proof the following obvious equivalent reformulation of the rule:
  \begin{align*}
    \partRed\ (\oplus)\ \id_\oplus\ n^m \rightarrow \iterateN\ m\ (\partRed\ (\oplus)\ \id_\oplus\ n)
  \end{align*}
  Proof by induction. We start with the base case, let $m= 0$.
  \begin{align*}
    \partRed\ (\oplus)\ \id_\oplus\ n^0\ xs &= \partRed\ (\oplus)\ \id_\oplus\ 1\ xs\\
      & \comment{definition of \partRed}\\
      &= xs\\
      &\comment{definition of \iterateN}\\
      &= \iterateN\ 0\ (\partRed\ (\oplus)\ \id_\oplus\ n)\ xs\\
  \end{align*}
  The induction step $(m-1) \rightarrow m$.
  Let $xs = [x_1, \ldots, x_l]$.
  \begin{align*}
    &\partRed\ (\oplus)\ \id_\oplus\ n^m\ xs\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n^m)}, \ldots, x_{\sigma(l-n^m+1)} \oplus \dots \oplus x_{\sigma(l)}]\\
    &\qquad \comment{accociativity of $\oplus$}\\
%    &\qquad = \begin{aligned}[t]
%       [\ &(x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}) \oplus \dots \oplus (x_{\sigma((n^{m-1}-1)\times n +1)} \oplus \dots \oplus x_{\sigma((n^{m-1})\times n)}),\\
%        &\ldots,\\
%        &
%          \begin{aligned}[b]
%            &(x_{\sigma(((l/n-(n^{m-1})+1)-1)\times n + 1)} \oplus \dots \oplus x_{\sigma((l/n-(n^{m-1})+1)\times n)})\\
%            &\quad \oplus \dots \oplus (x_{\sigma((l/n-1)\times n + 1)} \oplus \dots \oplus x_{\sigma(l/n\times n)})
%          \end{aligned}\ ]\\
%      \end{aligned}\\
    &\qquad = [y_1 \oplus \dots \oplus y_{(n^{m-1})}, \ldots, y_{(l/n - (n^{m-1}))} \oplus \dots \oplus y_{(l/n)}]\\
    &\qquad\qquad \text{where}\ y_i = (x_{\sigma((i-1)\times n + 1)} \oplus \dots \oplus x_{\sigma(i\times n)})\\
    &\qquad = \partRed\ (\oplus)\ \id_\oplus\ n^{(m-1)}\ [y_1, \ldots, y_{l/n}]\\
    &\qquad \comment{definition of $y_i$}\\
    &\qquad = \partRed\ (\oplus)\ \id_\oplus\ n^{(m-1)}\\
    &\qquad\qquad [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}, \ldots, x_{\sigma(l-n+1)} \oplus \dots \oplus x_{\sigma(l)}]\\
    &\qquad \comment{induction hypothesis}\\
    &\qquad = \iterateN\ (m-1)\ (\partRed\ (\oplus)\ \id_\oplus\ n)\\
    &\qquad\qquad [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}, \ldots, x_{\sigma(l-n+1)} \oplus \dots \oplus x_{\sigma(l)}]\\
    &\qquad \comment{definition of \partRed}\\
    &\qquad = \iterateN\ (m-1)\ (\partRed\ (\oplus)\ \id_\oplus\ n)\\
    &\qquad \qquad (\partRed\ (\oplus)\ \id_\oplus\ n\ xs)\\
    &\qquad \comment{definition of \iterateN}\\
    &\qquad = \iterateN\ m\ (\partRed\ (\oplus)\ \id_\oplus\ n)\ xs
  \end{align*}

%  \begin{align*}
%    &\iterateN\ m\ (\partRed\ (\oplus)\ \id_\oplus\ n)\ xs\\
%    &\qquad \comment{definition of \iterateN}\\
%    &\qquad = \iterateN\ (m-1)\ (\partRed\ (\oplus)\ \id_\oplus\ n)\ (\partRed\ (\oplus)\ \id_\oplus\ n\ xs)\\
%    &\qquad \comment{definition of \partRed}\\
%    &\qquad = \iterateN\ (m-1)\ (\partRed\ (\oplus)\ \id_\oplus\ n)\\
%    &\qquad\qquad [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}, \ldots, x_{\sigma(l-n+1)} \oplus \dots \oplus x_{l}]\\
%    &\qquad \comment{induction hypothesis}\\
%    &\qquad = \partRed\ (\oplus)\ \id_\oplus\ n^{(m-1)}\ [x_{\sigma(1)} \oplus \dots \oplus x_{\sigma(n)}, \ldots, x_{\sigma(l-n+1)} \oplus \dots \oplus x_{l}]\\
%    &\qquad = \partRed\ (\oplus)\ \id_\oplus\ n^{(m-1)}\ [y_1, \ldots, y_{l/n}]\\
%    &\qquad\qquad \text{where}\ y_i = x_{(i-1)\times n + 1} \oplus \dots \oplus x_{i\times n}\\
%    &\qquad \comment{definition of \partRed}\\
%    &\qquad = [y_1 \oplus \dots \oplus y_{(n^{m-1})}, \ldots, y_{(l/n - (n^{m-1}))} \oplus \dots \oplus y_{(l/n)}]\\
%    &\qquad \comment{definition of $y_i$}\\
%    &\qquad = \begin{aligned}[t]
%       [&\\
%        &(x_1 \oplus \dots \oplus x_n) \oplus \dots \oplus (x_{(n^{m-1}-1)\times n +1} \oplus \dots \oplus x_{(n^{m-1})\times n}),\\
%        &\ldots,\\
%        &
%          \begin{aligned}
%            &(x_{((l/n-(n^{m-1})+1)-1)\times n + 1} \oplus \dots \oplus x_{(l/n-(n^{m-1})+1)\times n})\\
%            &\quad \oplus \dots \oplus (x_{(l/n-1)\times n + 1} \oplus \dots \oplus x_{l/n\times n})
%          \end{aligned}\\
%        ]\\
%      \end{aligned}\\
%    &\qquad \comment{simplicfication and accociativity of $\oplus$}\\
%    &\qquad = [x_1 \oplus \dots \oplus x_{n^m}, \ldots, x_{l-n^m+1} \oplus \dots \oplus x_l]
%  \end{align*}
\end{proof}

\newpage
\paragraph{Simplification Rules}

We repeat \autoref{eq:algo:simpl} here:
\begin{rerule*}{lcl}
  \join_n \circ \splitN\ n       & \rightarrow & \id\\
  \splitN\ n \circ \join_n       & \rightarrow & \id\\
  \asScalar_n \circ \asVector\ n & \rightarrow & \id\\
  \asVector\ n \circ \asScalar_n & \rightarrow & \id
\end{rerule*}

\begin{proof}[Proof of option 1]
  Let $xs = [x_1, \ldots, x_m]$.
  \begin{align*}
    (\join_n \circ \splitN\ n)\ xs &= \join_n\ (\splitN\ n\ xs)\\
      &\comment{definition of \splitN}\\
      &= \join_n\ \big[ [x_1, \ldots, x_n], \ldots, [x_{m-n+1}, \ldots, x_m]\big]\\
      &\comment{definition of \join}\\
      &= xs
  \end{align*}
\end{proof}
\begin{proof}[Proof of option 2]
  Let $xs = \big[ [x_1, \ldots, x_n], \ldots, [x_{m-n+1}, \ldots, x_m]\big]$.
  \begin{align*}
    (\splitN\ n \circ \join_n)\ xs &= \splitN\ n\ (\join_n\ xs)\\
      &\comment{definition of \join}\\
      &= \splitN\ n\ [x_1, \ldots, x_m]\\
      &\comment{definition of \splitN}\\
      &= xs
  \end{align*}
\end{proof}
\begin{proof}[Proof of option 3]
  Let $xs = [x_1, \ldots, x_m]$.
  \begin{align*}
    &(\asScalar_n \circ \asVector\ n)\ xs = \asScalar_n\ (\asVector\ n\ xs)\\
    &\qquad\comment{definition of \asVector}\\
    &\qquad = \asScalar_n\ [\{x_1, \ldots, x_n\}, \ldots, \{x_{m-n+1}, \ldots, x_{m}\}]\\
    &\qquad\comment{definition of \asScalar}\\
    &\qquad = xs
  \end{align*}
\end{proof}
\begin{proof}[Proof of option 4]
  Let $xs = [\{x_1, \ldots, x_n\}, \ldots, \{x_{m-n+1}, \ldots, x_{m}\}]$.
  \begin{align*}
    &(\asVector\ n \circ \asScalar_n)\ xs = \asVector\ n\ (\asScalar_n\ xs)\\
    &\qquad\comment{definition of \asScalar}\\
    &\qquad = \asVector\ n\ [x_1, \ldots, x_m]\\
    &\qquad\comment{definition of \asVector}\\
    &\qquad = xs
  \end{align*}
\end{proof}

\paragraph{Fusion Rules}

We repeat \autoref{eq:algo:fusion} here:
\begin{rerule*}{lcl}
  \map\ f \circ \map\ g
    & \rightarrow & \map\ (f \circ g)\\
  \reduceSeq\ (\oplus)\ \id_\oplus \circ \map\ f
    & \rightarrow & \\
  {\hspace{3em}}
  \reduceSeq\
    \big(\ \lambda\ (a,b)\ .
      &\hspace{-.75em} a \oplus (f\ b)&\hspace{-.75em}\big)\ \id_\oplus
\end{rerule*}

\begin{proof}[Proof of option 1]
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
    (\map\ f\circ \map\ g)\ xs
      &= \map\ f\ (\map\ g\ xs)\\
      &\comment{definition of \map}\\
      &= \map\ f\ [g\ x_1, \ldots, g\ x_n]\\
      &\comment{definition of \map}\\
      &= [f\ (g\ x_1), \ldots, f\ (g\ x_n)]\\
      &\comment{definition of $\circ$}\\
      &= [(f\circ g)\ x_1, \ldots, (f\circ g)\ x_n]\\
      &\comment{definition of \map}\\
      &= \map (f\circ g)\ xs
  \end{align*}
\end{proof}
\begin{proof}[Proof of option 2]
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
    &(\reduceSeq\ (\oplus)\ \id_\oplus \circ \map\ f)\ xs\\
    &\qquad = \reduceSeq\ (\oplus)\ \id_\oplus\ (\map\ f\ xs)\\
    &\qquad \comment{definition of \map}\\
    &\qquad = \reduceSeq\ (\oplus)\ \id_\oplus\ [f\ x_1, f\ x_2, \ldots, f\ x_n]\\
    &\qquad \comment{definition of \reduceSeq}\\
    &\qquad = [ (\dots ((\id_\oplus \oplus (f\ x_1)) \oplus (f\ x_2)) \dots \oplus (f\ x_n)) ]\\
    &\qquad = [ (\dots ((\id_\oplus \odot x_1) \odot x_2) \dots \odot x_n) ]\\
    &\qquad\qquad \text{where } (\odot) = \lambda\ (a,b)\ .\ a \oplus (f\ b)\\
    &\qquad \comment{definition of \reduceSeq}\\
    &\qquad = \reduceSeq\ (\odot)\ \id_\oplus\ xs\\
    &\qquad \comment{definition of $\odot$}\\
    &\qquad = \reduceSeq\ \big(\ \lambda\ (a,b)\ .\ a \oplus (f\ b)\ \big)\ \id_\oplus\ xs
  \end{align*}
\end{proof}






\newpage



\section{\OpenCL-Specific Rules}

This section shows the proofs for the \OpenCL-specific rules defined in \autoref{section:rules:opencl}.


\paragraph{Maps}

We repeat \autoref{eq:low:map} here:
\begin{rerule*}{lclcl}
  \map
    & \rightarrow & \mapWorkgroup     & | & \mapLocal\\
    & | & \mapGlobal    & | & \mapWarp\\
    & | & \mapLane     & | & \mapSeq
\end{rerule*}

\begin{proof}[Proof]
  All of the options in this rule are correct by definition, as all map patterns share the same execution semantics.
\end{proof}


\paragraph{Reduction}

We repeat \autoref{eq:low:red} here:
\begin{rerule*}{lcl}
  \reduce\ (\oplus)\ \id_\oplus & \rightarrow & \reduceSeq\ (\oplus)\ \id_\oplus
\end{rerule*}

\begin{proof}[Proof]
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
      &\comment{definition of \reduce}\\
    \reduce\ (\oplus)\ \id_\oplus\ xs
      &= x_1 \oplus \dots \oplus x_n\\
      &\comment{associativity of $\oplus$ \& identity of $\id_\oplus$}\\
      &= (\dots ((\id_\oplus \oplus x_1) \oplus x_2)\dots \oplus x_n)\\
      &\comment{definition of \reduceSeq}\\
      &= \reduceSeq\ (\oplus)\ \id_\oplus\ xs
  \end{align*}
\end{proof}


\paragraph{Reorder}

We repeat \autoref{eq:low:stride} here:
\begin{rerule*}{lcl}
  \reorder & \rightarrow & \textit{id}\quad |\quad \reorderStride\ s
\end{rerule*}

\begin{proof}[Proof of option 1]
  Let $xs = [x_1, \ldots, x_n]$.
  \begin{align*}
    \reorder\ xs &= [x_{\sigma(1)}, \ldots, x_{\sigma(n)}]\\
                 &\comment{choose $\sigma$ as the identity permutation} \Rightarrow\\
                 & [x_{\sigma(1)}, \ldots, x_{\sigma(n)}] = [x_1, \ldots, x_n] = \id\ xs
  \end{align*}
\end{proof}

\begin{proof}[Proof of option 2]
  The definition of \reorderStride is as follows:
  \begin{align*}
    &\reorderStride\ s\ [x_1, \ldots, x_m] = [y_1, \ldots, y_m]\\
    &\qquad \text{where}\ y_i = x_{(i-1)\ \text{\normalfont div } n + s\times ((i-1) \bmod{n}) + 1}
  \end{align*}
  We can express the relationship between $ys$ and $xs$ as a function $\sigma$ with: $x_\sigma(i) = y_i$, \ie, $\sigma(i) = ((i-1)\ \text{div}\ n + s\times ((i-1) \bmod{n}) + 1$.
  We want to show that $\sigma$ is a permutation of the interval $[1, m]$, so that $\sigma$ is a valid choice when rewriting \reduce.
  We show the $\sigma$ is a permutation by proving that $\sigma$ is a bijective function mapping indices from the interval $[1,m]$ in the same interval.

  First we show the injectivity, by showing:
  \begin{align*}
    \forall i, j \in [1, m] \text{ with } i\neq j \quad \Rightarrow \quad \sigma(i)\neq \sigma(j)
  \end{align*}
  Let us assume without loss of generality that $i< j$.

%  We first proof the case where $i = 0$.
%  For $\sigma(i)$ we have:
%  \begin{align*}
%    \sigma(i) = (0\ \text{div}\ n) + s\times (0 \bmod{n}) = 0 + s\times 0 = 0
%  \end{align*}
%  For $\sigma(j$) we have:
%  \begin{align*}
%    \sigma(j) = (j\ \text{div}\ n) + s\times (j \bmod{n})
%  \end{align*}
%  Let us assume that $(j \bmod{n}) = 0$:
%  \begin{align*}
%    &\Rightarrow j \text{ is evenly divisible by $n$ and } n > 0\\
%    &\Rightarrow (j\ \text{div}\ n) > 0\\
%    &\Rightarrow (j\ \text{div}\ n) + \underbrace{s\times (j\bmod{n})}_{= 0} > 0
%  \end{align*}
%  If we assume the opposite, \ie, $(j \bmod{n}) \neq 0$:
%  \begin{align*}
%    &\Rightarrow \underbrace{(j\ \text{div}\ n)}_{\geq 0} + \underbrace{s}_{>0}\times \underbrace{(j\bmod{n})}_{>0} > 0
%  \end{align*}
%  As $\sigma(i) = 0$ and in both cases $\sigma(j)>0$: $\sigma(i) \neq \sigma(j)$ for $i = 0$.\\[1em]
%
%  We now proof the remaining case where $i\neq 0$.
  As $i,j\in [1,m]$ and by definition of $\bmod{}$ and div every summand in $\sigma$ is positive.
  Therefore, for $\sigma(i) = \sigma(j)$ to be true all of their corresponding summands have to be equal.
  We will show, that this can never be the case.
  Let us write $j$ as $j=i+k$ where $0<k<m-1$.

  If we assume: $(i-1)\ \text{div}\ n = (i+k-1)\ \text{div}\ n$
  \begin{align*}
    &\comment{definition of \text{div} \& $\bmod{}$ and $i,k > 0$}\\
    &\Rightarrow (i-1)\bmod{n} \neq (i+k-1)\bmod{n}\\
    &\comment{$s>0$}\\
    &\Rightarrow s \times ((i-1)\bmod{n}) \neq s \times ((i+k-1)\bmod{n})\\[.5em]
    &\Rightarrow ((i-1)\ \text{div}\ n) + s\times ((i-1)\bmod{n}) + 1\\
    &\quad \neq ((j-1)\ \text{div}\ n) + s\times ((j-1)\bmod{n}) + 1
  \end{align*}

  If we assume the opposite $(i-1)\bmod{n} = (i+k-1)\bmod{n}$:
  \begin{align*}
    &\comment{definition of \text{div} \& $\bmod{}$ and $i,k > 0$}\\
    &\Rightarrow (i-1)\ \text{div}\ n \neq (i+k-1)\ \text{div}\ n\\[.5em]
    &\Rightarrow ((i-1)\ \text{div}\ n) + s\times ((i-1)\bmod{n}) + 1\\
    &\quad \neq ((j-1)\ \text{div}\ n) + s\times ((j-1)\bmod{n}) + 1
  \end{align*}
  This shows the injectivity of $\sigma$.\\[.5em]

  \noindent
  Now we show the surjectivity, by showing:
  \begin{align*}
    \forall i \in [1, m]\quad \sigma(i)\in [1, m]
  \end{align*}
  We know that $m= s\times n$
  \begin{align*}
    &\Rightarrow (i-1)\ \text{div}\ n \leq s \quad \forall i\in [1,m]
  \end{align*}
  By definition of $\bmod{}$: $((i-1)\bmod{n}) \leq (n-1)\quad \forall i\in [1,m]$
  \begin{align*}
    &\Rightarrow ((i-1)\ \text{div}\ n) + s\times ((i-1)\bmod{n}) \leq s + s\times (n-1)\\
    &\quad = s\times n = m
  \end{align*}
  As already discussed is $\sigma(i)>0\ \forall i\in [1,m]$, because of the definitions of $\bmod{}$, div, and $\sigma$.

  Therefore, $\sigma$ is injective and surjective, thus, bijective which makes it a well defined permutation of $[1,m]$.

\end{proof}


\paragraph{Local and Global Memory}

We repeat \autoref{eq:low:mem} here:
\begin{rerule*}{lcl}
  \mapLocal\ f & \rightarrow & \toGlobal\ (\mapLocal\ f)\\
  \mapLocal\ f & \rightarrow & \toLocal\ (\mapLocal\ f)
\end{rerule*}

\begin{proof}[Proof]
  These rules follow directly from the definition of \toGlobal and \toLocal, as these have no effect on the computed value, \ie, they behave like the \id function.
\end{proof}


\paragraph{Vectorization}

We repeat \autoref{eq:algo:vect} here:
\begin{rerule*}{lcl}
  \map\ f
    & \rightarrow &
      \asScalar
        \circ \map\ (\vect\ n\ f)
        \circ \asVector\ n
\end{rerule*}


\begin{proof}[Proof]
  Let $xs = [x_1, \ldots, x_m]$.
  \begin{align*}
    &\map\ f\ xs = [f\ x_1, \ldots, f\ x_m]\\
    &\qquad \comment{definition of \asScalar}\\
    &\qquad = \asScalar\ [\{f\ x_1, \ldots, f\ x_n\}, \ldots ,\{f\ x_{m-n+1}, \ldots, f\ x_m\}]\\
    &\qquad = \asScalar\ [f_n\ \{x_1, \ldots, x_n\}, \ldots ,f_n\ \{x_{m-n+1}, \ldots, x_m\}]\\
    &\qquad \text{where } f_n\ \{x_1, \ldots, x_n\} = \{f\ x_1, \ldots, f\ x_n\}\\
    &\qquad \comment{definition of $f_n$ and \vect}\\
    &\qquad = \asScalar\
      \begin{aligned}[t]
        [&(\vect\ n\ f)\ \{x_1, \ldots, x_n\},\ \ldots ,\\
         &(\vect\ n\ f)\ \{x_{m-n+1}, \ldots, x_m\}]
      \end{aligned}\\
    &\qquad \comment{definition of \map}\\
    &\qquad = \asScalar\ (\map\ (\vect\ n\ f)\\
    &\qquad\qquad [\{x_1, \ldots, x_n\}, \ldots ,\{x_{m-n+1}, \ldots, x_m\}]\\
    &\qquad \comment{definition of \asVector}\\
    &\qquad = \asScalar\ (\map\ (\vect\ n\ f)\ (\asVector\ n\ xs))\\
    &\qquad = (\asScalar \circ \map\ (\vect\ n\ f) \circ \asVector\ n)\ xs
  \end{align*}
\end{proof}














%----------------------------------------------------------------------------------------

\chapter{Derivations for Parallel Reduction}
% \addtocontents{lof}{\protect\vspace{\beforebibskip}}%
\label{chapter:derivations}

This appendix shows the derivations which transform the high-level expression $\reduce\ (+)\ 0$ into the low-level expressions shown in \autoref{sec:deriving:reduce}.
The numbers above the equality sign refer to the rules from \autoref{fig:algoRules} and \autoref{fig:lowRules}.

\paragraph{First Pattern-Based Expression}
This is the derivation for the expression shown in \autoref{eq:reduce11}.

\small

\begin{align*}
  &\hspace{-1.5em}vecSum = \reduce\ (+)\ 0
%
  \overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \partRed\ (+)\ 0\ 128\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ (\partRed\ (+)\ 0\ 128)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\iterateN\ 7\ (\partRed\ (+)\ 0\ 2)\ \big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2)\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:identity}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\map\ id\ \circ \\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2)\ \circ\\
    &\qquad\quad\map\ id\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:splitjoin}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2)\ \circ\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:map}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2)\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
\end{align*}

\begin{align*}
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}\&\ref{fig:low:red}}{=\hspace{.2em}}\\[-.75em]
    &\qquad\ \ 
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2)\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:mem}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad \join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2)\ \circ\\
    &\qquad\quad \join \circ \toLocal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\\
    &\qquad\big) \circ \splitN\ 128
  \end{aligned}
%  
\end{align*}

\normalsize





\paragraph{Avoiding Interleaved Addressing}
This is the derivation for the expression shown in \autoref{eq:reduce12}.

\small

\begin{align*}
  &\hspace{-1.5em}vecSum = \reduce\ (+)\ 0
%
  \overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \partRed\ (+)\ 0\ 128\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ (\partRed\ (+)\ 0\ 128)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 7\ (\partRed\ (+)\ 0\ 2)\ \big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 7\ (\partRed\ (+)\ 0\ 2\ \circ \reorder)\ \big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:identity}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\map\ id\ \circ \\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\ \circ\\
    &\qquad\quad\map\ id\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:splitjoin}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\ \circ\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:map}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\ \circ \reorder)\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}\&\ref{fig:low:red}}{=\hspace{.2em}}\\[-.75em]
    &\qquad\ \ 
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorder)\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:stride}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\lambda\ xs\ .\ \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ ((size\ xs)/2)\ \$\ xs)\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\\
    &\qquad\big)\ \circ \splitN\ 128
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:mem}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad \join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\lambda\ xs\ .\ \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ ((size\ xs)/2)\ \$\ xs)\ \circ\\
    &\qquad \circ \join \circ \toLocal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\\
    &\qquad\big) \circ \splitN\ 128
  \end{aligned}
%  
\end{align*}

\normalsize




\paragraph{Increase Computational Intensity per Work-item}
This is the derivation for the expression shown in \autoref{eq:reduce13}.

\small

\begin{align*}
  &\hspace{-1.5em}vecSum = \reduce\ (+)\ 0
%
  \overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \partRed\ (+)\ 0\ 256\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ (\partRed\ (+)\ 0\ 256)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 8\ (\partRed\ (+)\ 0\ 2)\ \big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 8\ (\partRed\ (+)\ 0\ 2\ \circ \reorder)\ \big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 8\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:identity}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\map\ id\ \circ \\
    &\qquad\quad\iterateN\ 8\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:splitjoin}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 8\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\ \circ\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:map}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \mapLocal\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}\&\ref{fig:low:red}}{=\hspace{.2em}}\\[-.75em]
    &\qquad\ \ 
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorder)\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:stride}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \mapLocal\ (\mapSeq\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\lambda\ xs\ .\ \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ ((size\ xs)/2)\ \$\ xs )\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad\reorderStride\ 128\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:mem}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\iterateN\ 7\ (\lambda\ xs\ .\ \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ ((size\ xs)/2)\ \$\ xs )\ \circ\\
    &\qquad\quad\join \circ \toLocal\ (\mapLocal\ (\reduceSeq\ (+)\ 0)) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad\reorderStride\ 128\\
    &\qquad\big) \circ \splitN\ 256
  \end{aligned}
%  
\end{align*}

\normalsize




\paragraph{Avoid Synchronization Inside a Warp}
This is the derivation for the expression shown in \autoref{eq:reduce14}.

\small

\begin{align*}
  &\hspace{-1.5em}vecSum = \reduce\ (+)\ 0
%
  \overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \partRed\ (+)\ 0\ 256\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ (\partRed\ (+)\ 0\ 256)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\ \iterateN\ 8\ (\partRed\ (+)\ 0\ 2)\ \big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 6\ (\partRed\ (+)\ 0\ 2)\ \circ\\
    &\qquad\quad\iterateN\ 2\ (\partRed\ (+)\ 0\ 2)\ \big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ \iterateN\ 2\ (\partRed\ (+)\ 0\ 2\ \circ \reorder)\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\iterateN\ 2\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2 \circ \reorder)\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:identity}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\map\ id\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\iterateN\ 2\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:splitjoin}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\iterateN\ 2\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\ \circ\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 64)\ \splitN\ 64\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\ \iterateN\ 6\ (\partRed\ (+)\ 0\ 2)\ \big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\ \iterateN\ 6\ (\partRed\ (+)\ 0\ 2\ \circ \reorder)\ \big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\ \iterateN\ 6\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2)\circ \splitN\ 2 \circ\\
    &\qquad\qquad\reorder)\ \big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\\
    &\qquad\quad\big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder)\ \circ\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ 256
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:map}\ \&\ \ref{fig:algo:red}\ \&\ \ref{fig:low:red}\ \&\ \ref{fig:low:mem}}{=\hspace{.2em}}\\
    &\qquad
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad \join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad \join \circ \mapWarp\ (\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 1\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 2\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 4\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 8\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 16\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 32\\
    &\qquad\quad) \circ \splitN\ 64\ \circ\\
    &\qquad\quad \iterateN\ 1\ (\lambda\ xs\ .\ \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ ((size\ xs)/2)\ \$\ xs\ )\ \circ\\
    &\qquad\quad \join \circ \toLocal\ (\mapLocal\ (\reduceSeq\ (+)\ 0)) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ 128\\
    &\qquad\big) \circ \splitN\ 256
  \end{aligned}
%  
\end{align*}

\normalsize


\paragraph{Complete Loop Unrolling}
This is the derivation for the expression shown in \autoref{eq:reduce15}.
We continue with the last expression from the previous derivation.

\small

\begin{align*}
  &\hspace{-1.5em}vecSum = \reduce\ (+)\ 0\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\text{derivation above}}{=\hspace{.2em}}\\
    &\qquad
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad \join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad \join \circ \mapWarp\ (\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 1\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 2\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 4\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 8\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 16\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 32\\
    &\qquad\quad) \circ \splitN\ 64\ \circ\\
    &\qquad\quad \iterateN\ 1\ (\lambda\ xs\ .\ \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ ((size\ xs)/2)\ \$\ xs\ )\ \circ\\
    &\qquad\quad \join \circ \toLocal\ (\mapLocal\ (\reduceSeq\ (+)\ 0)) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ 128\\
    &\qquad\big) \circ \splitN\ 256
  \end{aligned}
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}\\
    &\qquad
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad \join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ \id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad \join \circ \mapWarp\ (\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 1\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 2\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 4\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 8\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 16\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 32\\
    &\qquad\quad) \circ \splitN\ 64\ \circ\\
    &\qquad\quad  \join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 64)\ \circ\\
    &\qquad\quad \join \circ \toLocal\ (\mapLocal\ (\reduceSeq\ (+)\ 0)) \circ \splitN\ 2\ \circ\\
    &\qquad\qquad \reorderStride\ 128\\
    &\qquad\big) \circ \splitN\ 256
  \end{aligned}
%  
\end{align*}

\normalsize


\paragraph{Fully Optimized Implementation}
This is the derivation for the expression shown in \autoref{eq:reduce16}.

\small

\begin{align*}
  &\hspace{-1.5em}vecSum = \reduce\ (+)\ 0
%
  \overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \partRed\ (+)\ 0\ blockSize\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ (\partRed\ (+)\ 0\ blockSize)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ \log_{2}(blockSize)\ (\partRed\ (+)\ 0\ 2)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 7\ (\partRed\ (+)\ 0\ 2)\ \circ\\
    &\qquad\quad\iterateN\ (\log_{2}(blockSize/128))\ (\partRed\ (+)\ 0\ 2)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\iterateN\ 6\ (\partRed\ (+)\ 0\ 2)\ \circ\\
    &\qquad\quad\iterateN\ 1\ (\partRed\ (+)\ 0\ 2)\ \circ\\
    &\qquad\quad\iterateN\ (\log_{2}(blockSize/128))\ (\partRed\ (+)\ 0\ 2)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:identity}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\map\ id\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:splitjoin}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 64)\ \splitN\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\ \iterateN\ 6\ (\partRed\ (+)\ 0\ 2)\ \big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\ \iterateN\ 6\ (\partRed\ (+)\ 0\ 2\ \circ \reorder)\ \big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*}
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\ \iterateN\ 6\ (\join \circ \map\ (\partRed\ (+)\ 0\ 2)\ \circ \splitN\ 2\ \circ\\
    &\qquad\qquad\reorder)\ \big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:iterate}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\\
    &\qquad\quad\big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\\
    &\qquad\quad\big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\partRed\ (+)\ 0\ 2\circ \reorder\ \circ \\
    &\qquad\quad\partRed\ (+)\ 0\ (blockSize/128)\circ \reorder \\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
\end{align*}

\begin{align*} 
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:algo:red}}{=\hspace{.2em}}
      \reduce \circ \join \circ \map\ \big(\\
    &\qquad\quad\join \circ \map\ (\map\ id) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \map\ \big(\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\ \circ\\
    &\qquad\qquad \join \circ \map\ (\partRed\ (+)\ 0\ 2))\circ \splitN\ 2 \circ \reorder\\
    &\qquad\quad\big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ 2) \circ \splitN\ 2\ \circ \reorder\ \circ \\
    &\qquad\quad\join \circ \map\ (\partRed\ (+)\ 0\ (blockSize/128)) \circ\\
    &\qquad\quad \splitN\ (blockSize/128)\circ \reorder\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}\\[.5em]
%
  &\hspace{-2em}\quad\begin{aligned}
    &\overset{\ref{fig:low:map}\ \&\ \ref{fig:algo:red}\ \&\ \ref{fig:low:red}\ \&\ \ref{fig:low:mem}}{=\hspace{.2em}}
      \reduce \circ \join \circ \mapWorkgroup\ \big(\\
    &\qquad\quad\join \circ \toGlobal\ (\mapLocal\ (\mapSeq\ id)) \circ \splitN\ 1\ \circ\\
    &\qquad\quad\join \circ \mapWarp\ \big(\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0))\circ \splitN\ 2 \circ \reorderStride\ 1\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0))\circ \splitN\ 2 \circ \reorderStride\ 2\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0))\circ \splitN\ 2 \circ \reorderStride\ 4\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0))\circ \splitN\ 2 \circ \reorderStride\ 8\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0))\circ \splitN\ 2 \circ \reorderStride\ 16\ \circ\\
    &\qquad\qquad \join \circ \mapLane\ (\reduceSeq\ (+)\ 0))\circ \splitN\ 2 \circ \reorderStride\ 32\\
    &\qquad\quad\big)\circ \splitN\ 64\ \circ\\
    &\qquad\quad\join \circ \mapLocal\ (\reduceSeq\ (+)\ 0) \circ \splitN\ 2\ \circ \reorderStride\ 64\ \circ \\
    &\qquad\quad\join \circ \toLocal\ (\mapLocal\ (\reduceSeq\ (+)\ 0)) \circ\\
    &\qquad\quad \splitN\ (blockSize/128)\circ \reorderStride\ 128\\
    &\qquad\big)\ \circ \splitN\ blockSize
  \end{aligned}
%  
\end{align*}

\normalsize
